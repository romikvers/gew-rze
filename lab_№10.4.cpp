//Створити текстовий файл, який містить числа і символи.Визначити в кожному рядку
//файлу середнє арифметичне та середнє геометричне чисел рядка.Переписати в новий
//текстовий файл числа з попереднього файлу та їх середні значення – середнє арифметичне та
//середнє геометричне.

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <stdio.h>
#include <fstream>
#include <string>
#include <Windows.h>

using namespace std;

void Create(char* fname)
{
	ofstream f(fname);
	if (!f)
	{
		cerr << "Помилка відкриття файлу '" << fname << "'" << endl;
		return;
	}
	char tekst[150];
	cout << "Введіть дані які хочете зберегти у файлі\n"; cin.getline(tekst, size(tekst));
	f << tekst << endl;
}
void PrintTXT(char* fname) // виведення файлу на екран
{
	ifstream fin(fname); // відкрили файл для зчитування
	string s; // прочитаний рядок
	while (getline(fin, s)) // поки можна прочитати рядок
	{
		cout << s << endl; // виводимо його на екран
	}
	cout << endl;
}
int ProcessTXT1(char* fname) 
{
	//FILE* fin;
	ifstream fin(fname); // відкрили файл для зчитування
	double A,  // Сер.арифмет.
		S = 0,
		m;        // прочитаний символ
	int k = 0;     // загальна кількість чиселї
	//if ((fin = fopen("123", "r")) == NULL)
	while (!fin)
	{
		cout << "file not opened\n";
		return 1;
	}
	while (!fin.eof())
	{
		fin >> m;
		cout << m << " ";
		S += m;
		k++;
	}

	/*cout << endl;
	do
	{
		fscanf(fin, "%d", &grade);
		fin.gets(m);
	   //fread(&m, sizeof(int), 1, fin);      //(fread(m, sizeof(float), 1, fin);
			S += m;
		    k++;
	} while (fin.eof());
	*/
	A = S / k;

	return A;
}
int ProcessTXT2(char* fname)
{
	ifstream fin(fname); // відкрили файл для зчитування
	double G,     // Сер.геом.
		S = 0,
		m;        // прочитаний символ
	int k = 0;    // загальна кількість чисел
	do{
		fin >> m;
		S *= m;
		k++;
	} while (!fin.eof());

	G = sqrt(S);

	return G;
}
int ProcessTXT3(char* fname) // обчислення кількості слів,
{ // відокремлених пробілами
	ifstream fin(fname); // відкрили файл для зчитування
	int s; // прочитаний символ
	int k = 0; // кількість слів
	while (fin >> s) // поки можна прочитати символ
	{
		k++; // збільшили кількість і вивели його на екран
		cout << k << ": " << s << endl;
	}
	return k;
}
/*
int ProcessTXT3(char* fname) // обчислення кількості слів,
{ // відокремлених пробілами та знаками пунктуації
	ifstream fin(fname); // відкрили файл для зчитування
	char s[100]; // прочитаний рядок
	char* w; // виокремлене з рядка слово
	int k = 0; // кількість слів
	while (fin.getline(s, sizeof(s))) // поки можна прочитати рядок
	{
		w = strtok(s, " .,:;!?-'"); // початок циклу виокремлення слів
		while (w != NULL) // поки можна виокремити слово
		{
			k++; // збільшуємо лічильник слів
			cout << k << ": " << w << endl; // виводимо слово
			w = strtok(NULL, " .,:;!?-'"); // виокремлюємо наступне слово
		}
	}
	return k;
}
void SortTXT(char* fname, char* gname) // сортування рядків текстового файлу
{
	ofstream g(gname); // відкрили другий файл для запису
	string s, mins, z = ""; // s – прочитаний з файлу f рядок
	// mins – рядок, який вважається
	// найменшим
   // z - записаний у файл g рядок
	int k; // - вказує, чи є ще рядки, які слід
	// записати у файл g
	do // цикл запису мінімального рядка
	{ // з тих, які ще не записані у файл g
		k = 0; // обнуляємо лічильник рядків, 
		// які слід записати
		ifstream f(fname); // відкрили перший файл для зчитування
		// тепер будемо читати файл з початку
		// цикл початку пошуку мінімального із ще не записаних рядків
		while (getline(f, s)) // поки можна зчитувати рядки
		{
			if (s <= z) // якщо цей рядок вже записаний у файл g
				continue; // - пропускаємо його 
			mins = s; // вважаємо перший ще не записаний рядок
			// - мінімальним
			k++; // знайшли ще не записаний рядок
			// - збільшили лічильник
			break; // вийшли з циклу присвоєння змінній
		} // mins початкового значення
		// цикл пошуку мінімального із ще не записаних рядків
		while (getline(f, s)) // поки можна зчитувати рядки
		{
			if (s <= z) // якщо цей рядок вже записаний у файл g
				continue; // - пропускаємо його
			if (s < mins) // якщо прочитаний рядок менший113
			{ // мінімального
				mins = s; // - вважаємо його мінімальним
				k++; // збільшили лічильник ще не записаних
			} // рядків
		}
		// запис мінімального з не записаних рядків у файл g
		z = mins; // будемо записувати знайдений
		// мінімальний з не записаних рядків
		if (k > 0) // якщо були знайдені ще не записані
			g << z << endl; // рядки - записуємо мінімальний з них
		f.close(); // закрили перший файл 
	} // щоб потім читати файл з початку
	while (k > 0); // повторюємо, поки є не записані рядки
}
void SwapValue(char* fname, char* gname) 
{
	ofstream g(gname); // відкрили другий файл для запису
	string s, mins, z = ""; // s – прочитаний з файлу f рядок
	do
	{
		ifstream f(fname); // відкрили перший файл для зчитування

		while (getline(f, s)) // поки можна зчитувати рядки
		{
			if (s <= z) // якщо цей рядок вже записаний у файл g
				continue; // - пропускаємо його 
			mins = s; // вважаємо перший ще не записаний рядок
			// - мінімальним
			k++; // знайшли ще не записаний рядок
			// - збільшили лічильник
			break; // вийшли з циклу присвоєння змінній
		} // mins початкового значення
		// цикл пошуку мінімального із ще не записаних рядків
		while (getline(f, s)) // поки можна зчитувати рядки
		{
			if (s <= z) // якщо цей рядок вже записаний у файл g
				continue; // - пропускаємо його
			if (s < mins) // якщо прочитаний рядок менший113
			{ // мінімального
				mins = s; // - вважаємо його мінімальним
				k++; // збільшили лічильник ще не записаних
			} // рядків
		}
		// запис мінімального з не записаних рядків у файл g
		z = mins; // будемо записувати знайдений
		// мінімальний з не записаних рядків
		if (k > 0) // якщо були знайдені ще не записані
			g << z << endl; // рядки - записуємо мінімальний з них
		f.close(); // закрили перший файл 
	} // щоб потім читати файл з початку
	while (k > 0); // повторюємо, поки є не записані рядки
}*/
void menu()
{
	SetConsoleCP(1251); // встановлення сторінки win-cp1251 в потік вводу
	SetConsoleOutputCP(1251); // встановлення сторінки win-cp1251 в потік виводу
	int k;
	char ch;
	char fname[61];
	char gname[61];
	do{
		cout << endl;
		cout << "Головне меню:" << endl;
		cout << "[1] - Введення та збереження данних;" << endl;
		cout << "[2] - Вивід данних;" << endl;
		cout << "[3] - Середнє арифметичне значення" << endl;
		cout << "[4] - Середнє геометричне значення" << endl;
		cout << "[5] - Переписати в новий текстовий файл числа з файлу, сер.знач.(арифм. та геом.)" << endl << endl;
		cout << "[0] - Завершення роботи." << endl << endl;
		cout << "Задайте команду з номером : "; cin >> k; cout << endl;
		switch (k)
		{
		case 1 :
			cin.get(); // очищуємо буфер клавіатури – щоб не було символу
			cin.sync(); // "кінець рядка", який залишився після вводу числа
			cout << "Введіть назву файлу : "; cin.getline(fname, sizeof(fname));
			Create(fname);
			break;
		case 2 :
			cin.get(); // очищуємо буфер клавіатури – щоб не було символу
			cin.sync(); // "кінець рядка", який залишився після вводу числа
			cout << "Введіть назву файлу : "; cin.getline(fname, sizeof(fname));
			PrintTXT(fname);
			break;
		case 3:
			cout << "Середнє арифм." <<ProcessTXT1(fname);
		case 4:
			cout << "Середнє геом." << ProcessTXT2(fname);
		case 5 :
			cin.get(); // очищуємо буфер клавіатури – щоб не було символу
			cin.sync(); // "кінець рядка", який залишився після вводу числа
			cout << "Введіть назву першого файлу : "; cin.getline(fname, sizeof(fname));
			cout << endl;
			cout << "Введіть назву другого файлу : "; cin.getline(gname, sizeof(fname));
		//	SwapValue(fname, gname);
		case 0 :
			break;
		default:
			cout << "Ви ввели помилкове значення! "
				"Слід ввести число - номер вибраного пункту меню" << endl;
		}
		cout << "\nБажаєте ще виконати команду (Y/N && y/n) ? : "; cin >> ch; cout << endl;
	} while (ch == 'Y' || ch == 'y');
}
int main()
{
	// text files
	char fname[100]; // ім'я першого файлу

	menu();
	//cout << "enter file name 1: "; cin >> fname;
	//PrintTXT(fname); // вивели вміст першого файлу на екран
    //cout << "k(Сер.арифм.) = " << ProcessTXT1(fname) << endl;
	//cout << "k(word1) = " << ProcessTXT2(fname) << endl;
	//cout << "k(word2) = " << ProcessTXT3(fname) << endl;
    //char gname[100]; // ім'я другого файлу
	//cout << "enter file name 2: "; cin >> gname;
	//SortTXT(fname, gname); // відсортували рядки першого файлу,
	// результат записали у другий файл
	return 0;
}